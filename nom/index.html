<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `nom` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, nom">

    <title>nom - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css"
          id="mainThemeStyle">
    
    <link rel="stylesheet" type="text/css" href="../dark.css">
    <link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
    <script src="../storage.js"></script>
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        <p class='location'>Crate nom</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'nom', ty: 'mod', relpath: '../'};</script></div>
    </nav>

    <div class="theme-picker">
        <button id="theme-picker" aria-label="Pick another theme!">
            <img src="../brush.svg" width="18" alt="Pick another theme!">
        </button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content"><h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>nom</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/nom/lib.rs.html#1-151' title='goto source code'>[src]</a></span></h1><div class='docblock'><p>nom, eating data byte by byte</p>
<p>nom is a parser combinator library with a focus on safe parsing,
streaming patterns, and as much as possible zero copy.</p>
<p>The code is available on <a href="https://github.com/Geal/nom">Github</a></p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">IResult</span>,<span class="ident">digit</span>};
<span class="kw">use</span> <span class="ident">nom</span>::<span class="ident">IResult</span>::<span class="kw-2">*</span>;

<span class="comment">// Parser definition</span>

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">parens</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>, <span class="macro">delimited</span><span class="macro">!</span>(
    <span class="macro">char</span><span class="macro">!</span>(<span class="string">&#39;(&#39;</span>),
    <span class="ident">expr</span>,
    <span class="macro">char</span><span class="macro">!</span>(<span class="string">&#39;)&#39;</span>)
  )
);

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">i64_digit</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">map_res</span><span class="macro">!</span>(
    <span class="macro">map_res</span><span class="macro">!</span>(
      <span class="ident">digit</span>,
      <span class="ident">str</span>::<span class="ident">from_utf8</span>
    ),
    <span class="ident">FromStr</span>::<span class="ident">from_str</span>
  )
);

<span class="comment">// We transform an integer string into a i64</span>
<span class="comment">// we look for a digit suite, and try to convert it.</span>
<span class="comment">// if either str::from_utf8 or FromStr::from_str fail,</span>
<span class="comment">// the parser will fail</span>
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">factor</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">alt</span><span class="macro">!</span>(
    <span class="ident">i64_digit</span>
  <span class="op">|</span> <span class="ident">parens</span>
  )
);

<span class="comment">// we define acc as mutable to update its value whenever a new term is found</span>
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">term</span> <span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">chain</span><span class="macro">!</span>(
    <span class="kw-2">mut</span> <span class="ident">acc</span>: <span class="ident">factor</span>  ~
             <span class="macro">many0</span><span class="macro">!</span>(
               <span class="macro">alt</span><span class="macro">!</span>(
                 <span class="macro">tap</span><span class="macro">!</span>(<span class="ident">mul</span>: <span class="macro">preceded</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;*&quot;</span>), <span class="ident">factor</span>) <span class="op">=&gt;</span> <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">*</span> <span class="ident">mul</span>) <span class="op">|</span>
                 <span class="macro">tap</span><span class="macro">!</span>(<span class="ident">div</span>: <span class="macro">preceded</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;/&quot;</span>), <span class="ident">factor</span>) <span class="op">=&gt;</span> <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">/</span> <span class="ident">div</span>)
               )
             ),
    <span class="op">||</span> { <span class="kw">return</span> <span class="ident">acc</span> }
  )
);

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">expr</span> <span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
  <span class="macro">chain</span><span class="macro">!</span>(
    <span class="kw-2">mut</span> <span class="ident">acc</span>: <span class="ident">term</span>  ~
             <span class="macro">many0</span><span class="macro">!</span>(
               <span class="macro">alt</span><span class="macro">!</span>(
                 <span class="macro">tap</span><span class="macro">!</span>(<span class="ident">add</span>: <span class="macro">preceded</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;+&quot;</span>), <span class="ident">term</span>) <span class="op">=&gt;</span> <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">+</span> <span class="ident">add</span>) <span class="op">|</span>
                 <span class="macro">tap</span><span class="macro">!</span>(<span class="ident">sub</span>: <span class="macro">preceded</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;-&quot;</span>), <span class="ident">term</span>) <span class="op">=&gt;</span> <span class="ident">acc</span> <span class="op">=</span> <span class="ident">acc</span> <span class="op">-</span> <span class="ident">sub</span>)
               )
             ),
    <span class="op">||</span> { <span class="kw">return</span> <span class="ident">acc</span> }
  )
);

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expr</span>(<span class="string">b&quot;1+2&quot;</span>),         <span class="ident">IResult</span>::<span class="ident">Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">3</span>));
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expr</span>(<span class="string">b&quot;12+6-4+3&quot;</span>),    <span class="ident">IResult</span>::<span class="ident">Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">17</span>));
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expr</span>(<span class="string">b&quot;1+2*3+4&quot;</span>),     <span class="ident">IResult</span>::<span class="ident">Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">11</span>));

  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expr</span>(<span class="string">b&quot;(2)&quot;</span>),         <span class="ident">IResult</span>::<span class="ident">Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">2</span>));
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expr</span>(<span class="string">b&quot;2*(3+4)&quot;</span>),     <span class="ident">IResult</span>::<span class="ident">Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">14</span>));
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expr</span>(<span class="string">b&quot;2*2/(5-1)+3&quot;</span>), <span class="ident">IResult</span>::<span class="ident">Done</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..], <span class="number">4</span>));
}</pre>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.add_error.html"
                                  title='macro nom::add_error'>add_error</a></td>
                           <td class='docblock-short'>
                                <p>Add an error if the child parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt.html"
                                  title='macro nom::alt'>alt</a></td>
                           <td class='docblock-short'>
                                <p><code>alt!(I -&gt; IResult&lt;I,O&gt; | I -&gt; IResult&lt;I,O&gt; | ... | I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
try a list of parsers, return the result of the first successful one</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt_complete.html"
                                  title='macro nom::alt_complete'>alt_complete</a></td>
                           <td class='docblock-short'>
                                <p>This is a combination of the <code>alt!</code> and <code>complete!</code> combinators. Rather
than returning <code>Incomplete</code> on partial input, <code>alt_complete!</code> will try the
next alternative in the chain. You should use this only if you know you
will not receive partial input for the rules you're trying to match (this
is almost always the case for parsing programming languages).</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply.html"
                                  title='macro nom::apply'>apply</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply_m.html"
                                  title='macro nom::apply_m'>apply_m</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying for method calls on structs
<code>apply!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bits.html"
                                  title='macro nom::bits'>bits</a></td>
                           <td class='docblock-short'>
                                <p><code>bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;</code>
transforms its byte slice input into a bit stream for the underlying parsers</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call.html"
                                  title='macro nom::call'>call</a></td>
                           <td class='docblock-short'>
                                <p>Used to wrap common expressions and function as macros</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call_m.html"
                                  title='macro nom::call_m'>call_m</a></td>
                           <td class='docblock-short'>
                                <p>Used to called methods then move self back into self</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.chain.html"
                                  title='macro nom::chain'>chain</a></td>
                           <td class='docblock-short'>
                                <p><code>chain!(I-&gt;IResult&lt;I,A&gt; ~ I-&gt;IResult&lt;I,B&gt; ~ ... I-&gt;IResult&lt;I,X&gt; , || { return O } ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
chains parsers and assemble the results through a closure</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.char.html"
                                  title='macro nom::char'>char</a></td>
                           <td class='docblock-short'>
                                <p>matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.closure.html"
                                  title='macro nom::closure'>closure</a></td>
                           <td class='docblock-short'>
                                <p>Wraps a parser in a closure</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.complete.html"
                                  title='macro nom::complete'>complete</a></td>
                           <td class='docblock-short'>
                                <p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond.html"
                                  title='macro nom::cond'>cond</a></td>
                           <td class='docblock-short'>
                                <p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_reduce.html"
                                  title='macro nom::cond_reduce'>cond_reduce</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_with_error.html"
                                  title='macro nom::cond_with_error'>cond_with_error</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.consumer_from_parser.html"
                                  title='macro nom::consumer_from_parser'>consumer_from_parser</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count.html"
                                  title='macro nom::count'>count</a></td>
                           <td class='docblock-short'>
                                <p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count_fixed.html"
                                  title='macro nom::count_fixed'>count_fixed</a></td>
                           <td class='docblock-short'>
                                <p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg.html"
                                  title='macro nom::dbg'>dbg</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message if the parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg_dmp.html"
                                  title='macro nom::dbg_dmp'>dbg_dmp</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message and the input if the parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.delimited.html"
                                  title='macro nom::delimited'>delimited</a></td>
                           <td class='docblock-short'>
                                <p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error.html"
                                  title='macro nom::error'>error</a></td>
                           <td class='docblock-short'>
                                <p>Prevents backtracking if the child parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped.html"
                                  title='macro nom::escaped'>escaped</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
matches a byte string with escaped characters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped_transform.html"
                                  title='macro nom::escaped_transform'>escaped_transform</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_opt.html"
                                  title='macro nom::expr_opt'>expr_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Some</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_res.html"
                                  title='macro nom::expr_res'>expr_res</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result&lt;T,E&gt; and returns a IResult::Done(I,T) if Ok</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fix_error.html"
                                  title='macro nom::fix_error'>fix_error</a></td>
                           <td class='docblock-short'>
                                <p>translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.flat_map.html"
                                  title='macro nom::flat_map'>flat_map</a></td>
                           <td class='docblock-short'>
                                <p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many0.html"
                                  title='macro nom::fold_many0'>fold_many0</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many1.html"
                                  title='macro nom::fold_many1'>fold_many1</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many_m_n.html"
                                  title='macro nom::fold_many_m_n'>fold_many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i16.html"
                                  title='macro nom::i16'>i16</a></td>
                           <td class='docblock-short'>
                                <p>if parameter is true, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i32.html"
                                  title='macro nom::i32'>i32</a></td>
                           <td class='docblock-short'>
                                <p>if parameter is true, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i64.html"
                                  title='macro nom::i64'>i64</a></td>
                           <td class='docblock-short'>
                                <p>if parameter is true, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a.html"
                                  title='macro nom::is_a'>is_a</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a_s.html"
                                  title='macro nom::is_a_s'>is_a_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not.html"
                                  title='macro nom::is_not'>is_not</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not_s.html"
                                  title='macro nom::is_not_s'>is_not_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_bytes.html"
                                  title='macro nom::length_bytes'>length_bytes</a></td>
                           <td class='docblock-short'>
                                <p>`length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;
gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_value.html"
                                  title='macro nom::length_value'>length_value</a></td>
                           <td class='docblock-short'>
                                <p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many0.html"
                                  title='macro nom::many0'>many0</a></td>
                           <td class='docblock-short'>
                                <p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many1.html"
                                  title='macro nom::many1'>many1</a></td>
                           <td class='docblock-short'>
                                <p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_m_n.html"
                                  title='macro nom::many_m_n'>many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of results in a Vec</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map.html"
                                  title='macro nom::map'>map</a></td>
                           <td class='docblock-short'>
                                <p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_opt.html"
                                  title='macro nom::map_opt'>map_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_res.html"
                                  title='macro nom::map_res'>map_res</a></td>
                           <td class='docblock-short'>
                                <p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.method.html"
                                  title='macro nom::method'>method</a></td>
                           <td class='docblock-short'>
                                <p>Makes a method from a parser combination</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named.html"
                                  title='macro nom::named'>named</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.none_of.html"
                                  title='macro nom::none_of'>none_of</a></td>
                           <td class='docblock-short'>
                                <p>matches anything but the provided characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.not.html"
                                  title='macro nom::not'>not</a></td>
                           <td class='docblock-short'>
                                <p><code>not!(I -&gt; IResult&lt;I,0&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Incomplete
does not consume the input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.one_of.html"
                                  title='macro nom::one_of'>one_of</a></td>
                           <td class='docblock-short'>
                                <p>matches one of the provided characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt.html"
                                  title='macro nom::opt'>opt</a></td>
                           <td class='docblock-short'>
                                <p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt_res.html"
                                  title='macro nom::opt_res'>opt_res</a></td>
                           <td class='docblock-short'>
                                <p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.pair.html"
                                  title='macro nom::pair'>pair</a></td>
                           <td class='docblock-short'>
                                <p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.peek.html"
                                  title='macro nom::peek'>peek</a></td>
                           <td class='docblock-short'>
                                <p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.preceded.html"
                                  title='macro nom::preceded'>preceded</a></td>
                           <td class='docblock-short'>
                                <p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.recognize.html"
                                  title='macro nom::recognize'>recognize</a></td>
                           <td class='docblock-short'>
                                <p><code>recognize!(&amp;[T] -&gt; IResult&lt;&amp;[T], O&gt; ) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list.html"
                                  title='macro nom::separated_list'>separated_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list.html"
                                  title='macro nom::separated_nonempty_list'>separated_nonempty_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_pair.html"
                                  title='macro nom::separated_pair'>separated_pair</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.switch.html"
                                  title='macro nom::switch'>switch</a></td>
                           <td class='docblock-short'>
                                <p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag.html"
                                  title='macro nom::tag'>tag</a></td>
                           <td class='docblock-short'>
                                <p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_bits.html"
                                  title='macro nom::tag_bits'>tag_bits</a></td>
                           <td class='docblock-short'>
                                <p>matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_s.html"
                                  title='macro nom::tag_s'>tag_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take.html"
                                  title='macro nom::take'>take</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_bits.html"
                                  title='macro nom::take_bits'>take_bits</a></td>
                           <td class='docblock-short'>
                                <p><code>take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;</code>
generates a parser consuming the specified number of bits.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_s.html"
                                  title='macro nom::take_s'>take_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_str.html"
                                  title='macro nom::take_str'>take_str</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till.html"
                                  title='macro nom::take_till'>take_till</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till_s.html"
                                  title='macro nom::take_till_s'>take_till_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till_s!(&amp;str -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until.html"
                                  title='macro nom::take_until'>take_until</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume.html"
                                  title='macro nom::take_until_and_consume'>take_until_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume_s.html"
                                  title='macro nom::take_until_and_consume_s'>take_until_and_consume_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either.html"
                                  title='macro nom::take_until_either'>take_until_either</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either_and_consume.html"
                                  title='macro nom::take_until_either_and_consume'>take_until_either_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_s.html"
                                  title='macro nom::take_until_s'>take_until_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while.html"
                                  title='macro nom::take_while'>take_while</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1.html"
                                  title='macro nom::take_while1'>take_while1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1!(&amp;[T] -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1_s.html"
                                  title='macro nom::take_while1_s'>take_while1_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while_s.html"
                                  title='macro nom::take_while_s'>take_while_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tap.html"
                                  title='macro nom::tap'>tap</a></td>
                           <td class='docblock-short'>
                                <p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser's result without affecting it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.terminated.html"
                                  title='macro nom::terminated'>terminated</a></td>
                           <td class='docblock-short'>
                                <p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.try_parse.html"
                                  title='macro nom::try_parse'>try_parse</a></td>
                           <td class='docblock-short'>
                                <p>A bit like <code>std::try!</code>, this macro will return the remaining input and parsed value if the child parser returned <code>Done</code>,
and will do an early return for <code>Error</code> and <code>Incomplete</code>
this can provide more flexibility than <code>chain!</code> if needed</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tuple.html"
                                  title='macro nom::tuple'>tuple</a></td>
                           <td class='docblock-short'>
                                <p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u16.html"
                                  title='macro nom::u16'>u16</a></td>
                           <td class='docblock-short'>
                                <p>if parameter is true, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u32.html"
                                  title='macro nom::u32'>u32</a></td>
                           <td class='docblock-short'>
                                <p>if parameter is true, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u64.html"
                                  title='macro nom::u64'>u64</a></td>
                           <td class='docblock-short'>
                                <p>if parameter is true, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.value.html"
                                  title='macro nom::value'>value</a></td>
                           <td class='docblock-short'>
                                <p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>

                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ChainConsumer.html"
                                  title='struct nom::ChainConsumer'>ChainConsumer</a></td>
                           <td class='docblock-short'>
                                <p>ChainConsumer takes a consumer C1 R -&gt; S, and a consumer C2 S -&gt; T, and makes a consumer R -&gt; T by applying C2 on C1's result</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.FileProducer.html"
                                  title='struct nom::FileProducer'>FileProducer</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.MapConsumer.html"
                                  title='struct nom::MapConsumer'>MapConsumer</a></td>
                           <td class='docblock-short'>
                                <p>MapConsumer takes a function S -&gt; T and applies it on a consumer producing values of type S</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.MemProducer.html"
                                  title='struct nom::MemProducer'>MemProducer</a></td>
                           <td class='docblock-short'>
                                <p>A MemProducer generates values from an in memory byte buffer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ProducerRepeat.html"
                                  title='struct nom::ProducerRepeat'>ProducerRepeat</a></td>
                           <td class='docblock-short'>
                                <p>ProducerRepeat takes a single value, and generates it at each step</p>

                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.ConsumerState.html"
                                  title='enum nom::ConsumerState'>ConsumerState</a></td>
                           <td class='docblock-short'>
                                <p>Stores a consumer's current computation state</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Err.html"
                                  title='enum nom::Err'>Err</a></td>
                           <td class='docblock-short'>
                                <p>Contains the error that a parser can return</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.ErrorKind.html"
                                  title='enum nom::ErrorKind'>ErrorKind</a></td>
                           <td class='docblock-short'>
                                <p>indicates which parser returned an error</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.FileProducerState.html"
                                  title='enum nom::FileProducerState'>FileProducerState</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.IResult.html"
                                  title='enum nom::IResult'>IResult</a></td>
                           <td class='docblock-short'>
                                <p>Holds the result of parsing functions</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Input.html"
                                  title='enum nom::Input'>Input</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Move.html"
                                  title='enum nom::Move'>Move</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Needed.html"
                                  title='enum nom::Needed'>Needed</a></td>
                           <td class='docblock-short'>
                                <p>Contains information on needed data if a parser returned <code>Incomplete</code></p>

                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.AsBytes.html"
                                  title='trait nom::AsBytes'>AsBytes</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.AsChar.html"
                                  title='trait nom::AsChar'>AsChar</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Consumer.html"
                                  title='trait nom::Consumer'>Consumer</a></td>
                           <td class='docblock-short'>
                                <p>The Consumer trait wraps a computation and its state</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.GetInput.html"
                                  title='trait nom::GetInput'>GetInput</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.GetOutput.html"
                                  title='trait nom::GetOutput'>GetOutput</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.HexDisplay.html"
                                  title='trait nom::HexDisplay'>HexDisplay</a></td>
                           <td class='docblock-short'>
                                <p>useful functions to calculate the offset between slices and show a hexdump of a slice</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.InputLength.html"
                                  title='trait nom::InputLength'>InputLength</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.IterIndices.html"
                                  title='trait nom::IterIndices'>IterIndices</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Producer.html"
                                  title='trait nom::Producer'>Producer</a></td>
                           <td class='docblock-short'>
                                <p>The producer wraps a data source, like file or network, and applies a consumer on it</p>

                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.add_error_pattern.html"
                                  title='fn nom::add_error_pattern'>add_error_pattern</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alpha.html"
                                  title='fn nom::alpha'>alpha</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes lowercase and uppercase alphabetic characters: a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alphanumeric.html"
                                  title='fn nom::alphanumeric'>alphanumeric</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes numerical and alphabetic characters: 0-9a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.anychar.html"
                                  title='fn nom::anychar'>anychar</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_f32.html"
                                  title='fn nom::be_f32'>be_f32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian 4 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_f64.html"
                                  title='fn nom::be_f64'>be_f64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian 8 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i8.html"
                                  title='fn nom::be_i8'>be_i8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i16.html"
                                  title='fn nom::be_i16'>be_i16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i32.html"
                                  title='fn nom::be_i32'>be_i32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i64.html"
                                  title='fn nom::be_i64'>be_i64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u8.html"
                                  title='fn nom::be_u8'>be_u8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u16.html"
                                  title='fn nom::be_u16'>be_u16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u32.html"
                                  title='fn nom::be_u32'>be_u32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u64.html"
                                  title='fn nom::be_u64'>be_u64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.begin.html"
                                  title='fn nom::begin'>begin</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.code_from_offset.html"
                                  title='fn nom::code_from_offset'>code_from_offset</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.compare_error_paths.html"
                                  title='fn nom::compare_error_paths'>compare_error_paths</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.crlf.html"
                                  title='fn nom::crlf'>crlf</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.digit.html"
                                  title='fn nom::digit'>digit</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes numerical characters: 0-9</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.eof.html"
                                  title='fn nom::eof'>eof</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes empty input buffers</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.eol.html"
                                  title='fn nom::eol'>eol</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.error_to_list.html"
                                  title='fn nom::error_to_list'>error_to_list</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.error_to_u32.html"
                                  title='fn nom::error_to_u32'>error_to_u32</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.generate_colors.html"
                                  title='fn nom::generate_colors'>generate_colors</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hex_digit.html"
                                  title='fn nom::hex_digit'>hex_digit</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes hexadecimal numerical characters: 0-9, A-F, a-f</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hex_u32.html"
                                  title='fn nom::hex_u32'>hex_u32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a hex-encoded integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_alphabetic.html"
                                  title='fn nom::is_alphabetic'>is_alphabetic</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_alphanumeric.html"
                                  title='fn nom::is_alphanumeric'>is_alphanumeric</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_digit.html"
                                  title='fn nom::is_digit'>is_digit</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_hex_digit.html"
                                  title='fn nom::is_hex_digit'>is_hex_digit</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_oct_digit.html"
                                  title='fn nom::is_oct_digit'>is_oct_digit</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_space.html"
                                  title='fn nom::is_space'>is_space</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_f32.html"
                                  title='fn nom::le_f32'>le_f32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian 4 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_f64.html"
                                  title='fn nom::le_f64'>le_f64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian 8 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i8.html"
                                  title='fn nom::le_i8'>le_i8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i16.html"
                                  title='fn nom::le_i16'>le_i16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i32.html"
                                  title='fn nom::le_i32'>le_i32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i64.html"
                                  title='fn nom::le_i64'>le_i64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u8.html"
                                  title='fn nom::le_u8'>le_u8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u16.html"
                                  title='fn nom::le_u16'>le_u16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u32.html"
                                  title='fn nom::le_u32'>le_u32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u64.html"
                                  title='fn nom::le_u64'>le_u64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.length_value.html"
                                  title='fn nom::length_value'>length_value</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.line_ending.html"
                                  title='fn nom::line_ending'>line_ending</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a line feed</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.multispace.html"
                                  title='fn nom::multispace'>multispace</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes spaces, tabs, carriage returns and line feeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.newline.html"
                                  title='fn nom::newline'>newline</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.non_empty.html"
                                  title='fn nom::non_empty'>non_empty</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes non empty buffers</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.not_line_ending.html"
                                  title='fn nom::not_line_ending'>not_line_ending</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.oct_digit.html"
                                  title='fn nom::oct_digit'>oct_digit</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes octal characters: 0-7</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.prepare_errors.html"
                                  title='fn nom::prepare_errors'>prepare_errors</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.print.html"
                                  title='fn nom::print'>print</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.print_codes.html"
                                  title='fn nom::print_codes'>print_codes</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.print_error.html"
                                  title='fn nom::print_error'>print_error</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.print_offsets.html"
                                  title='fn nom::print_offsets'>print_offsets</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.reset_color.html"
                                  title='fn nom::reset_color'>reset_color</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.rest.html"
                                  title='fn nom::rest'>rest</a></td>
                           <td class='docblock-short'>
                                <p>Return the remaining input.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.rest_s.html"
                                  title='fn nom::rest_s'>rest_s</a></td>
                           <td class='docblock-short'>
                                <p>Return the remaining input, for strings.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.shift.html"
                                  title='fn nom::shift'>shift</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.sized_buffer.html"
                                  title='fn nom::sized_buffer'>sized_buffer</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.slice_to_offsets.html"
                                  title='fn nom::slice_to_offsets'>slice_to_offsets</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.space.html"
                                  title='fn nom::space'>space</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes spaces and tabs</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.tab.html"
                                  title='fn nom::tab'>tab</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.tag_cl.html"
                                  title='fn nom::tag_cl'>tag_cl</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.write_color.html"
                                  title='fn nom::write_color'>write_color</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt><kbd>?</kbd></dt>
                    <dd>Show this help dialog</dd>
                    <dt><kbd>S</kbd></dt>
                    <dd>Focus the search field</dd>
                    <dt><kbd>↑</kbd></dt>
                    <dd>Move up in search results</dd>
                    <dt><kbd>↓</kbd></dt>
                    <dd>Move down in search results</dd>
                    <dt><kbd>↹</kbd></dt>
                    <dd>Switch tab</dd>
                    <dt><kbd>&#9166;</kbd></dt>
                    <dd>Go to active search result</dd>
                    <dt><kbd>+</kbd></dt>
                    <dd>Expand all sections</dd>
                    <dt><kbd>-</kbd></dt>
                    <dd>Collapse all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "nom";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>